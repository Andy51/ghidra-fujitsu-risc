# Definitions from https://www.fujitsu.com/downloads/MICRO/fma/pdfmcu/CM71-00101-4E.pdf
#   FR Family
#   32 bit microcontroller
#   Instruction Manual

define endian=big;
define alignment=2;

define space ram type=ram_space size=4 default;
define space register type=register_space size=4;

# General purpose registers.
define register offset=0 size=4 [R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15];
# Missing the Program Status (PS) register here, it's modelled later.
define register offset=0x50 size=4 [PC TBR RP SSP USP];
# Special 8-byte multiplication/divsion register.
define register offset=0x100 size=8 [MD];
define register offset=0x100 size=4 [MDH];
define register offset=0x104 size=4 [MDL];

# Program Status register parts:
# 1. Status Bits
define register offset=0x150 size=1 [_ _ S I N Z V C];
# 2. Interrupt Level Mask
define register offset=0x200 size=1 [ILM];
# 3. System Condition Code
define register offset=0x250 size=1 [D1 D0 T_FLAG];


define token instr(16)
    type_a_Ri = (0, 3)
    type_a_Rj = (4, 7)
    type_a_OP = (8, 15)

    type_b_Ri = (0, 3)
    type_b_i8 = (4, 11)
    type_b_i8_signed = (4, 11) signed
    type_b_OP = (12, 15)

    type_c_Ri = (0, 3)
    type_c_i4 = (4, 7)
    type_c_i4_signed = (4, 7) signed
    type_c_OP = (8, 15)

    type_d_u8 = (0, 7)
    type_d_OP = (8, 15)

    type_e_Ri = (0, 3)
    type_e_Rs = (0, 3)
    type_e_OP = (4, 15)

    type_f_rel11 = (0, 10)
    type_f_OP = (11, 15)

    opcode_00_15 = (0, 15)
;
define token data16 (16)
    imm16 = (0, 15)
;
define token data32 (32)
    imm32 = (0, 31)
;

attach variables [type_a_Ri type_a_Rj type_b_Ri type_c_Ri type_e_Ri] [
    R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
];
attach variables [type_e_Rs] [
    TBR RP SSP USP MDH MDL _ _ _ _ _ _ _ _ _ _
];

macro resultFlags(result) {
    Z = (result == 0);
	N = (result s< 0);
}

macro additionResultFlags(operand_1, operand_2, result) {
    resultFlags(result);

    local result_sign = result[31, 1];
    V = (operand_1[31, 1] ^ result_sign) & (operand_2[31, 1] ^ result_sign);
    C = scarry(operand_1, operand_2);
}

macro subtractionResultFlags(operand_1, operand_2, result) {
    resultFlags(result);

    local result_sign = result[31, 1];
    V = (operand_1[31, 1] ^ result_sign) & (operand_2[31, 1] ^ result_sign);
    C = sborrow(operand_1, operand_2);
}

:ADD type_a_Rj, type_a_Ri
is type_a_OP=0b10100110 & type_a_Rj & type_a_Ri
{
    local result = type_a_Ri + type_a_Rj;

    additionResultFlags(type_a_Ri, type_a_Rj, result);
    type_a_Ri = result;
}

:ADD #type_c_i4, type_c_Ri
is type_c_OP=0b10100100 & type_c_Ri & type_c_i4
{
    local extended_imm4:4 = type_c_i4;
    local result = type_c_Ri + extended_imm4;

    additionResultFlags(extended_imm4, type_c_Ri, result);
    type_c_Ri = result;
}

:ADD2 #type_c_i4_signed, type_c_Ri
is type_c_OP=0b10100101 & type_c_Ri & type_c_i4_signed
{
    local extended_imm4:4 = type_c_i4_signed;
    local result = type_c_Ri + extended_imm4;

    additionResultFlags(extended_imm4, type_c_Ri, result);
    type_c_Ri = result;
}

:ADDC type_a_Rj, type_a_Ri
is type_a_OP=0b10100111 & type_a_Rj & type_a_Ri
{
    local registers_result = type_a_Ri + type_a_Rj;
    local c_tmp = zext(C);
    local result = registers_result + c_tmp;

    additionResultFlags(type_a_Ri, type_a_Rj, result);
    type_a_Ri = result;

    # Different handling of the carry flag here to account for three operands.
    C = scarry(registers_result, c_tmp);
}

# ADDN opcodes do addition without affecting flags.

:ADDN type_a_Rj, type_a_Ri
is type_a_OP=0b10100010 & type_a_Rj & type_a_Ri
{
    type_a_Ri = type_a_Ri + type_a_Rj;
}

:ADDN #type_c_i4, type_c_Ri
is type_c_OP=0b10100000 & type_c_Ri & type_c_i4
{
    type_c_Ri = type_c_Ri + type_c_i4;
}

:ADDN2 #type_c_i4_signed, type_c_Ri
is type_c_OP=0b10100001 & type_c_Ri & type_c_i4_signed
{
    type_c_Ri = type_c_Ri + type_c_i4_signed;
}

:SUB type_a_Rj, type_a_Ri
is type_a_OP=0b10101100 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj - type_a_Ri;

    subtractionResultFlags(type_a_Rj, type_a_Ri, result);
    type_a_Ri = result;
}

:SUBC type_a_Rj, type_a_Ri
is type_a_OP=0b10101101 & type_a_Rj & type_a_Ri
{
    local registers_result = type_a_Rj - type_a_Ri;
    local c_tmp = zext(C);
    local result = registers_result - c_tmp;

    subtractionResultFlags(type_a_Rj, type_a_Ri, result);

    # Different handling of the carry flag here to account for three operands.
    C = sborrow(registers_result, c_tmp);
}

:SUBN type_a_Rj, type_a_Ri
is type_a_OP=0b10101110 & type_a_Rj & type_a_Ri
{
    type_a_Ri = type_a_Rj - type_a_Ri;
}

:CMP type_a_Rj, type_a_Ri
is type_a_OP=0b10101010 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj - type_a_Ri;
    subtractionResultFlags(type_a_Rj, type_a_Ri, result);
}

:CMP #type_c_i4, type_c_Ri
is type_c_OP=0b10101000 & type_c_Ri & type_c_i4
{
    local extended_imm4:4 = type_c_i4;
    local result = type_c_Ri - extended_imm4;

    subtractionResultFlags(type_c_Ri, extended_imm4, result);
}

:CMP2 #type_c_i4_signed, type_c_Ri
is type_c_OP=0b10101001 & type_c_Ri & type_c_i4_signed
{
    local extended_imm4:4 = type_c_i4_signed;
    local result = type_c_Ri - extended_imm4;

    subtractionResultFlags(type_c_Ri, extended_imm4, result);
}

:AND type_a_Rj, type_a_Ri
is type_a_OP=0b10000010 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj & type_a_Ri;
    resultFlags(result);
    type_a_Ri = result;
}

:AND type_a_Rj, @type_a_Ri
is type_a_OP=0b10000100 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj & (*type_a_Ri);
    resultFlags(result);
    *type_a_Ri = result;
}

:ANDH type_a_Rj, @type_a_Ri
is type_a_OP=0b10000101 & type_a_Rj & type_a_Ri
{
    local result:2 = type_a_Rj:2 & (*:2 type_a_Ri);
    resultFlags(result);
    *:2 type_a_Ri = result;
}

:ANDB type_a_Rj, @type_a_Ri
is type_a_OP=0b10000110 & type_a_Rj & type_a_Ri
{
    local result:1 = type_a_Rj:1 & (*:1 type_a_Ri);
    resultFlags(result);
    *:1 type_a_Ri = result;
}

:OR type_a_Rj, type_a_Ri
is type_a_OP=0b10010010 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj | type_a_Ri;
    resultFlags(result);
    type_a_Ri = result;
}

:OR type_a_Rj, @type_a_Ri
is type_a_OP=0b10010100 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj | (*type_a_Ri);
    resultFlags(result);
    *type_a_Ri = result;
}

:ORH type_a_Rj, @type_a_Ri
is type_a_OP=0b10010101 & type_a_Rj & type_a_Ri
{
    local result:2 = type_a_Rj:2 | (*:2 type_a_Ri);
    resultFlags(result);
    *:2 type_a_Ri = result;
}

:ORB type_a_Rj, @type_a_Ri
is type_a_OP=0b10010110 & type_a_Rj & type_a_Ri
{
    local result:1 = type_a_Rj:1 | (*:1 type_a_Ri);
    resultFlags(result);
    *:1 type_a_Ri = result;
}

:EOR type_a_Rj, type_a_Ri
is type_a_OP=0b10011010 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj ^ type_a_Ri;
    resultFlags(result);
    type_a_Ri = result;
}

:EOR type_a_Rj, @type_a_Ri
is type_a_OP=0b10011100 & type_a_Rj & type_a_Ri
{
    local result = type_a_Rj ^ (*type_a_Ri);
    resultFlags(result);
    *type_a_Ri = result;
}

:EORH type_a_Rj, @type_a_Ri
is type_a_OP=0b10011101 & type_a_Rj & type_a_Ri
{
    local result:2 = type_a_Rj:2 ^ (*:2 type_a_Ri);
    resultFlags(result);
    *:2 type_a_Ri = result;
}

:EORB type_a_Rj, @type_a_Ri
is type_a_OP=0b10011110 & type_a_Rj & type_a_Ri
{
    local result:1 = type_a_Rj:1 ^ (*:1 type_a_Ri);
    resultFlags(result);
    *:1 type_a_Ri = result;
}

:BANDL #type_c_i4, type_c_Ri
is type_c_OP=0b10000000 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0x0F) & type_c_i4;
    *:1 type_c_Ri = (memory_value & 0xF0) | (result & 0x0F);
}

:BANDH #type_c_i4, type_c_Ri
is type_c_OP=0b10000001 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0xF0) & (type_c_i4 << 4);
    *:1 type_c_Ri = (result & 0xF0) | (memory_value & 0x0F);
}

:BORL #type_c_i4, type_c_Ri
is type_c_OP=0b10010000 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0x0F) | type_c_i4;
    *:1 type_c_Ri = (memory_value & 0xF0) | (result & 0x0F);
}

:BORH #type_c_i4, type_c_Ri
is type_c_OP=0b10010001 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0xF0) | (type_c_i4 << 4);
    *:1 type_c_Ri = (result & 0xF0) | (memory_value & 0x0F);
}

:BEORL #type_c_i4, type_c_Ri
is type_c_OP=0b10011000 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0x0F) ^ type_c_i4;
    *:1 type_c_Ri = (memory_value & 0xF0) | (result & 0x0F);
}

:BEORH #type_c_i4, type_c_Ri
is type_c_OP=0b10011001 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0xF0) ^ (type_c_i4 << 4);
    *:1 type_c_Ri = (result & 0xF0) | (memory_value & 0x0F);
}

:BTSTL #type_c_i4, type_c_Ri
is type_c_OP=0b10001000 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0x0F) & type_c_i4;

    N = 0;
    Z = (result == 0);
}

:BTSTH #type_c_i4, type_c_Ri
is type_c_OP=0b10001001 & type_c_Ri & type_c_i4
{
    local memory_value:1 = *:1 type_c_Ri;
    local result = (memory_value & 0xF0) & (type_c_i4 << 4);

    N = 0;
    Z = (result == 0);
}

macro multiplicationResultFlags(result) {
    N = (MDL s< 0);
    V = (result & 0xFFFFFFFF) == result;
    Z = (result == 0);
}


:MUL type_a_Rj, type_a_Ri
is type_a_OP=0b10101111 & type_a_Rj & type_a_Ri
{
    local result:8 = sext(type_a_Rj) * sext(type_a_Ri);
    MD = result;
    multiplicationResultFlags(result);
}

:MULU type_a_Rj, type_a_Ri
is type_a_OP=0b10101011 & type_a_Rj & type_a_Ri
{
    local result:8 = zext(type_a_Rj) * zext(type_a_Ri);
    MD = result;
    multiplicationResultFlags(result);
}

:MULH type_a_Rj, type_a_Ri
is type_a_OP=0b10111111 & type_a_Rj & type_a_Ri
{
    local result:8 = sext(type_a_Rj:2) * sext(type_a_Ri:2);
    MD = result;
    multiplicationResultFlags(result);
}

:MULUH type_a_Rj, type_a_Ri
is type_a_OP=0b10111011 & type_a_Rj & type_a_Ri
{
    local result:8 = zext(type_a_Rj:2) * zext(type_a_Ri:2);
    MD = result;
    multiplicationResultFlags(result);
}

:DIV0S type_e_Ri
is type_e_OP=0b100101110100 & type_e_Ri
{
    D0 = (MDL s< 0);
    D1 = (MDL s< 0) ^ (type_e_Ri s< 0);

    MD = sext(MDL);
}

:DIV0U type_e_Ri
is type_e_OP=0b100101110101 & type_e_Ri
{
    D0 = 0;
    D1 = 0;
    MDH = 0;
}

:DIV1 type_e_Ri
is type_e_OP=0b100101110110 & type_e_Ri
{
    MD = MD << 1;
    # Performs MDH + R_i if D1 == 1, otherwise MDH - R_i
    if (D1 == 1) goto <positive>;

    tmp = MDH - type_e_Ri;
    C = sborrow(MDH, type_e_Ri);

    goto <after_step>;
<positive>
    tmp = MDH + type_e_Ri;
    C = scarry(MDH, type_e_Ri);

<after_step>
    Z = (tmp == 0);

    if ((D0 ^ D1 ^ C) != 0) goto <end>;
    MDH = tmp;
    MDL[0,1] = 1;
<end>
}

:DIV2 type_e_Ri
is type_e_OP=0b100101110111 & type_e_Ri
{
    # Performs MDH + R_i if D1 == 1, otherwise MDH - R_i
    if (D1 == 1) goto <positive>;

    C = sborrow(MDH, type_e_Ri);

    goto <after_step>;
<positive>
    C = scarry(MDH, type_e_Ri);

<after_step>
    if (Z != 1) goto <end>;
    MDH = 0;
<end>
}

:DIV3
is opcode_00_15=0b1001111101100000
{
    if (Z != 1) goto <end>;
    MDL = MDL + 1;
<end>
}

:DIV4S
is opcode_00_15=0b1001111101110000
{
    if (Z != 1) goto <end>;
    MDL = 0 - MDL;
<end>
}

:LSL type_a_Rj, type_a_Ri
is type_a_OP=0b10110110 & type_a_Rj & type_a_Ri
{
    local result = type_a_Ri << type_a_Rj;
    type_a_Ri = result;

    resultFlags(result);
}

:LSL #type_c_i4, type_c_Ri
is type_c_OP=0b10110100 & type_c_Ri & type_c_i4
{
    local result = type_c_Ri << type_c_i4;
    type_c_Ri = result;

    resultFlags(result);
}

:LSL2 #type_c_i4, type_c_Ri
is type_c_OP=0b10110101 & type_c_Ri & type_c_i4
{
    local result = type_c_Ri << (type_c_i4 + 16);
    type_c_Ri = result;

    resultFlags(result);
}

:LSR type_a_Rj, type_a_Ri
is type_a_OP=0b10110010 & type_a_Rj & type_a_Ri
{
    local result = type_a_Ri >> type_a_Rj;
    type_a_Ri = result;

    resultFlags(result);
}

:LSR #type_c_i4, type_c_Ri
is type_c_OP=0b10110000 & type_c_Ri & type_c_i4
{
    local result = type_c_Ri >> type_c_i4;
    type_c_Ri = result;

    resultFlags(result);
}

:LSR2 #type_c_i4, type_c_Ri
is type_c_OP=0b10110001 & type_c_Ri & type_c_i4
{
    local result = type_c_Ri >> (type_c_i4 + 16);
    type_c_Ri = result;

    resultFlags(result);
}

:ASR type_a_Rj, type_a_Ri
is type_a_OP=0b10111010 & type_a_Rj & type_a_Ri
{
    local result = type_a_Ri s>> type_a_Rj;
    type_a_Ri = result;

    resultFlags(result);
}

:ASR #type_c_i4, type_c_Ri
is type_c_OP=0b10111000 & type_c_Ri & type_c_i4
{
    local result = type_c_Ri s>> type_c_i4;
    type_c_Ri = result;

    resultFlags(result);
}

:ASR2 #type_c_i4, type_c_Ri
is type_c_OP=0b10111001 & type_c_Ri & type_c_i4
{
    local result = type_c_Ri s>> (type_c_i4 + 16);
    type_c_Ri = result;

    resultFlags(result);
}

:LDI":"32 #imm32, type_e_Ri
is type_e_OP=0b100111111000 & type_e_Ri; imm32
{
    type_e_Ri = imm32;
}

:LDI":"20 #imm20, type_c_Ri
is type_c_OP=0b10011011 & type_c_Ri & type_c_i4; imm16[ imm20 = (type_c_i4 << 16) | imm16; ]
{
    type_c_Ri = imm20;
}

:LDI":"8 #type_b_i8, type_b_Ri
is type_b_OP=0b1100 & type_b_i8 & type_b_Ri
{
    type_b_Ri = type_b_i8;
}

:LD @type_a_Rj, type_a_Ri
is type_a_OP=0b00000100 & type_a_Rj & type_a_Ri
{
    type_a_Ri = *type_a_Rj;
}

:LD @("R13" + type_a_Rj), type_a_Ri
is type_a_OP=0b00000000 & type_a_Rj & type_a_Ri
{
    type_a_Ri = *(type_a_Rj + R13);
}

:LD @("R14" + 4 * type_b_i8_signed), type_b_Ri
is type_b_OP=0b0010 & type_b_i8_signed & type_b_Ri
{
    type_b_Ri = *(R14 + (4 * type_b_i8_signed));
}

:LD @("R15" + 4 * type_c_i4), type_c_Ri
is type_c_OP=0b00000011 & type_c_Ri & type_c_i4
{
    type_c_Ri = *(R15 + (4 * type_c_i4));
}

:LD @"R15+", type_e_Ri
is type_e_OP=0b000001110000 & type_e_Ri
{
    type_e_Ri = *R15;
    R15 = R15 + 4;
}

:NOP
is opcode_00_15=0b1001111110100000
{
}
